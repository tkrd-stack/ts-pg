# typescript

## 実行環境

ローカル環境でコンパイルする環境

```terminal
npm i -g typescript
tsc index.ts
```

## 開発環境

```terminal
npm i -D typescript
npm install --save @types/node
```

## 型注釈（型アノテーション）

- どのような値が代入できるのか制約するものを「型」と言う。
- 決められた型のみが代入され、プログラムが安全に操作することができる。

```typescript
const message: string = 'hello';
// :string　の部分が型注釈
```

### 基本的な型

- boolean:真偽値
- number:数値
- string:文字列
- bigint:大きな整数
- symbol:一意の値
- undefined:未定義
- null:値が存在しない

### 特殊な型

- any:何でも代入できる型。値に対する操作の制限がなく、安全でなくなる。(ポケモンで言うメタモン)
- unknown:any 型と似ていて、なんでも代入できる型。代入した値によって型が変化する。しかし、値に対する操作が制限される。(ポケモンで言うイーブイ)
- void:値が存在しないことを示す。関数の返り値に何も返しませんよと言う時に使う。
- never:決して何も返さない時に使う。エラーを投げる関数などに使う。

## 型エイリアス

- 既存の型を新たな名前で定義する。
- 複雑な方を簡素にしたり、コードの可読性を向上させる。

## 読み取り専用配列

- 値の変更ができない宣言。
- readonly 型[] で読み取り専用配列になる。
- ReadonlyArray<型名>でもできる。

- 破壊的メソッドを呼び出そうとすることで警告が出るだけであり、実装・コンパイルされた後でメソッドを実行することはできる。

## タプル型

- 配列の要素数と要素の方が固定される。
- 要素のインデックス毎に型が決まる。

## オブジェクト

### オブジェクトの型注釈

- {プロパティ 1:型, プロパティ:型...}の形式で記述する。
- プロパティに読み取り専用をつけることもできる。

### オブジェクトメソッド

- オブジェクトに関数を持たせることができる。これをメソッドと呼ぶ。

### インデックス型

- インデックス型を利用してオブジェクト任意のキーと値の型を宣言することができる。
- 任意のキーで値を取得することができる。
- Record<K, T>を用いても表現できます。
- 複数のインデックスを設定する場合は注意が必要。[key:string]:number,[key:number]:number は string と number で暗黙的型変換が行われるため、型の競合が発生する。

### ショートハンドプロパティネーム

プロパティの名前がすでに定義されている変数である場合は、そのプロパティ名を省略できる。

## オプションプロパティ(?)

- 省略可能なプロパティ。

## オプショナルチェーン

- ?.演算子を用いてプロパティに安全にアクセスする。
- エラーが発生して処理が止まったりしなくなる。

## Map

### map 　オブジェクト

- キーとキーに対応する値のコレクション。
- キーはオブジェクトも可能。

### map の型注釈(型アノテーション)

- Map の型注釈は Map<キーの型, 値の型>の形で記述。

## Set

### set オブジェクト

- 同じ値が存在しないコレクション。
- 要素はなんでも可能。

### set の型注釈

Set<型>で記述。

## 列挙型(Enum)

### 列挙型の基本

- 関連する一連の数値もしくは文字列の集まりを定義する。(曜日、月、色、など)
- enum キーワードを使って宣言、定義する。
- 定義された集まりは上から順に 0 から昇順でフリ番される。
- フリ番のスタートを指定することもできる。

## ユニオン型

- 複数の型の内いずれかを取る値を表現できる。
- 型 1|型 2|型 3|...の形式で使う。
- 一つ以上の異なる型の値を同じ変数で扱う場合に使用。

### 判別可能なユニオン型

- タグ付きユニオンや直和型と呼ばれることもある。
- 共通のリテラル型のプロパティを持つ特別なユニオン型
- 共通のプロパティを利用して、型を判別できる。
- 特徴
  - オブジェクトの型でユニオンされている。
  - 各オブジェクトの型を判別するためのプロパティ(ディスクリミネータ)を持つ。
  - ディスクリミネータはリテラル型などであること。
    - リテラル
      - 文字
      - 数値
      - 論理
    - null
    - undefined
  - ディスクリミネータがあれば、各オブジェクトの型は固有のプロパティを持っても良い。

## インターセクション型

- 複数の方を一つに結合した新しい型を定義する。
- 型 1 & 型 2 & ... の形式で宣言する。
- 定義された新しい型はそれぞれの型が持つすべてのプロパティとメソッドを備える。

## 制御フロー分析

処理の流れに応じて変数の型を絞り込むことができる。

### ユニオン型の曖昧さ

ユニオン型で型注釈を設定すると、持たないメソッドやプロパティへのアクセスをするとエラーが発生する。

```typescript
function showMonth(month: string | number) {
  console.log(month.padStart(2, '0')); //waringが発生
}
```

### 制御フロー分析

条件分岐などの制御フローを分析することで、コードが実行されるタイミングで型の可能性を判断している。

```typescript
function showMonth(month: string | number) {
  if (month === 'string') {
    console.log(month.padStart(2, '0')); //waringが発生しない
  }
}
```

## 型ガード

### typeof

型の曖昧さを回避するために比較演算子で条件判定をして、型を絞り込んだ。このような型のチェックを型ガードという。

```typescript
function showMonth(month: string | number) {
  if (typeof month === 'string') {
    console.log(month.padStart(2, '0'));
  }
}
```

### instanceof

- js の初期仕様で typeof null をした場合、結果として"object"が返される仕様になってしまっている。
- 特定のクラスから生成されたインスタンスであるかを確認したい時は instanceof を使用すること。

### in

- in 演算子でオブジェクトが特定のプロパティを持つかを判定することもできる。
- in 演算子はオブジェクトのプロパティをチェックするために使う。
- 文字列やプリミティブな型に対しては、=== を使用して比較を行います。

## 分割代入引数

関数の引数に分割代入を使うことができる。アロー関数でも使える。
引数が配列やオブジェクトの場合、そのオブジェクトの一部を関数で利用したい場合に便利。

```javascript:配列
function foo([a,b]){
  console.log(a,b);
}
foo([1,2,3]);//1 2
```

```javascript:オブジェクト
function bar({ a, b }) {
  console.log(a, b);
}
bar({ a: 1, b: 2, c: 3 }); // 1 2
```

### 分割代入の型注釈

分割代入引数の右側に型注釈を書く。

## 型ガード関数

特定の型であることを判定する関数(型ガード関数)を利用することで、型が絞り込まれる。

## クラス

- フィールド宣言に型注釈をつけることができる。

### アクセス修飾子

- public どこからでもアクセス可能
- protected 自身のクラスとサブクラスからアクセス可能
- private 自身のクラスのみアクセス可能

### コンストラクタショートハンド

- コンストラクタパラメータにアクセス修飾子をつけると、自動的にフィールドが定義される。

### 静的フィールドと静的メソッド

- static キーワードを使うことで、インスタンスではなくクラス自体に関するフィールドやメソッドを定義される。

### クラスの継承

- extends キーワードにより、クラスの継承が可能。
- スーパークラス(親クラス)のプロパティ・メソッドの値はサブクラス(子クラス)からアクセス可能。

### instanceof

オブジェクトが特定のクラスのインスタンスであることを判定できる。

### 抽象クラス

- abstract キーワードにより、抽象クラスを定義できる。
- 抽象クラスはインスタンス化できず、他のクラスが継承するための基底クラスに使用される。
- 基底とは物事の基礎となる事柄。土台となる事柄を意味する。

### getter と setter

- オブジェクトのプロパティを取得。設定するためのメソッド。
- getter は get キーワードで、setter は set キーワードで定義する。

### インターフェース構文

- オブジェクトの形状を定義することが可能。
- プロパティやメソッドのシグネチャを記述することができる。
- シグネチャとは関数やメソッドの名前、引数の数やデータ型、返り値の型などの組み合わせのことを意味する。
- readonly 修飾子を使用して、プロパティを読み取り専用に設定できる。
- 呼び出し方には２通りある。

```typescript:宣言
interface Point {
  readonly x: number;
  readonly y: number;
  sum():number;
}
```

```typescript:呼び出し方1
const point: Point {
  const x = 10;
  const y = 20;
  sum(){
    return x + y;
  }
}
```

```typescript:呼び出し方2
class Point2 implement Point {
  const x = 10;
  const y = 20;
  sum(){
    return x + y;
  }
}
```

### abstract と interface の違い

- イメージはカテゴリーが別れるものは interface。
- カテゴリ内で分類されるものが abstract。
- 例：棚がインターフェース、鉄製の棚は抽象クラス

## 例外処理

### カスタムエラークラス

- カスタムエラークラスを作成することも可能。
- Error クラスを継承したカスタムクラスで、具体的なエラータイプを作成することができる。

##　非同期処理
非同期プログラミングをサポートしていて、コード内で時間を要する処理を効率的に扱うことができる。
